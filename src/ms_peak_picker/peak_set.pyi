from .utils import Base as Base, ppm_error as ppm_error
from typing import Any, Iterable, Iterator, Optional, Tuple, Union

class FittedPeak(Base):
    mz: float = ...
    intensity: float = ...
    signal_to_noise: float = ...
    peak_count: int = ...
    index: int = ...
    full_width_at_half_max: float = ...
    area: float = ...
    left_width: float = ...
    right_width: float = ...
    def __init__(self, mz: float, intensity: float, signal_to_noise: float, peak_count: int, index: int,
                 full_width_at_half_max: float, area: float, left_width: float = ..., right_width: float = ...) -> None: ...

    def clone(self) -> FittedPeak: ...
    def __reduce__(self): ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...


class PeakSet(Base):
    peaks: Tuple[FittedPeak] = ...
    def __init__(self, peaks: Iterable[FittedPeak]) -> None: ...
    def __len__(self) -> int: ...
    def reindex(self) -> None: ...
    def has_peak(self, mz: float, tolerance: float = ...) -> Optional[FittedPeak]: ...
    def get_nearest_peak(self, mz: float) -> Tuple[FittedPeak, float]: ...
    def __getitem__(self, item: int) -> Union[FittedPeak, PeakSet]: ...
    def __iter__(self) -> Iterator[FittedPeak]: ...
    def clone(self) -> PeakSet: ...
    def between(self, m1: float, m2: float) -> Tuple[FittedPeak]: ...
    def all_peaks_for(self, mz: float, error_tolerance: float = ...) -> Tuple[FittedPeak]: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...


def binary_search(array: Any, value: Any,
                  tolerance: float = ..., verbose: bool = ...): ...


def to_array(peak_set: Any): ...
def simple_peak(mz: float, intensity: float, fwhm: float = ...) -> FittedPeak: ...
def is_peak(obj: Any) -> bool: ...
